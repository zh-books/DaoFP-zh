\documentclass[DaoFP]{subfiles}
\begin{document}

 \chapter{Clean Slate\\白板}

 编程始于类型（Types）和函数（Functions）。你可能对类型和函数是什么有一些先入为主的观念：抛弃它们！它们会混淆你的思维。

 不要考虑事物是如何在硬件中实现的。计算机只是众多计算模型中的一种。我们不应该依附于此。你可以在脑海中进行计算，或者使用笔和纸进行计算。物理载体与编程的思想无关。

 \section{Types and Functions\\类型与函数}

 引用老子的话\footnote{老子的现代拼写是Laozi，但我会使用传统的拼写。老子是《道德经》（Tao Te Ching或Daodejing）的半传奇作者，这是一部关于道教的经典著作。}：\emph{“可描述的类型不是永恒的类型。”} 换句话说，类型（Type）是一种原始概念。它无法被定义。

 我们可以不称它为“类型”，而是称为“对象”（Object）或“命题”（Proposition）。在数学的不同领域（如类型论、范畴论和逻辑）中，这些词汇被用来描述它。

 可能有不止一种类型，所以我们需要一种方式来命名它们。我们可以通过指向它们来做到这一点，但为了有效地与他人交流，我们通常为它们命名。因此，我们会谈论类型 $a$、$b$、$c$；或者 \hask{Int}、\hask{Bool}、\hask{Double} 等等。这些只是名称。

 类型本身没有意义。使它特别的是它如何与其他类型连接。这些连接由箭头（Arrows）描述。一个箭头有一个类型作为其源，另一个类型作为其目标。目标可以与源相同，在这种情况下，箭头会回环。

 类型之间的箭头称为“函数”（Function）。对象之间的箭头称为“态射”（Morphism）。命题之间的箭头称为“蕴涵”（Entailment）。这些只是用来描述不同数学领域中的箭头的词汇。你可以互换使用它们。

 命题是可能为真的东西。在逻辑中，我们将两个对象之间的箭头解释为 $a$ 蕴涵 $b$，或者 $b$ 可以从 $a$ 推导出来。

 在两个类型之间可能有多个箭头，所以我们需要为它们命名。例如，这里有一个从类型 $a$ 到类型 $b$ 的箭头，叫做 $f$。

 \[ a \xrightarrow f b \]

 解释这一点的一种方式是说函数 $f$ 接受一个类型为 $a$ 的参数，并生成一个类型为 $b$ 的结果。或者说 $f$ 是一种证明，如果 $a$ 为真，那么 $b$ 也为真。

 注意：类型论、lambda 演算（Lambda Calculus，编程的基础）、逻辑和范畴论之间的联系被称为 Curry-Howard-Lambek 对应（Curry-Howard-Lambek Correspondence）。

 \section{Yin and Yang\\阴阳}

 一个对象由它的连接来定义。箭头（Arrow）是两个对象连接的证明，一个证据。有时没有证明，对象是断开的；有时有很多证明；有时只有一个证明——两个对象之间的唯一箭头。

 什么是\emph{唯一的}？这意味着如果你能找到两个这样的东西，那么它们一定是相等的。

 一个对每个对象都有唯一出射箭头的对象称为“初始对象”（Initial Object）。

 它的对偶是一个从每个对象都有唯一入射箭头的对象。它被称为“终端对象”（Terminal Object）。

 在数学中，初始对象通常表示为 $0$，终端对象表示为 $1$。

 从 $0$ 到任何对象 $a$ 的箭头表示为 $\mbox{!`}_a$，通常缩写为 $\mbox{!`}$。

 从任何对象 $a$ 到 $1$ 的箭头表示为 $!_a$，通常缩写为 $!$。

 初始对象是一切的源头。作为一种类型，它在 Haskell 中被称为 \hask{Void}。它象征着一切事物源于其中的混沌。由于有一个从 \hask{Void} 到一切事物的箭头，也有一个从 \hask{Void} 到它自身的箭头。

 \[
  \begin{tikzcd}
   \hask{Void}
   \arrow[loop]
  \end{tikzcd}
 \]

 因此，\hask{Void} 产生了 \hask{Void} 和其他一切。

 终端对象将一切联合起来。作为一种类型，它被称为 \hask{Unit}。它象征着终极秩序。

 在逻辑中，终端对象象征着终极真理，用 $T$ 或 $ \top$ 表示。事实是，从任何对象到它都有一个箭头，这意味着无论你的假设是什么，$ \top$ 都是正确的。

 相对地，初始对象象征逻辑谬误、矛盾或反事实。它写作 False，用倒 T 符号 $ \bot$ 表示。事实是，从它到任何对象都有一个箭头，这意味着你可以从错误的前提开始证明任何事情。

 在英语中，有一种特殊的语法结构用于反事实蕴涵。当我们说，“如果愿望是马，乞丐会骑马”，我们的意思是愿望与马的等价性意味着乞丐能够骑马。但我们知道这个前提是错误的。

 编程语言让我们可以相互交流，也可以与计算机交流。有些语言对计算机来说更容易理解，另一些则更接近理论。我们将使用 Haskell 作为折中。

 在 Haskell 中，终端类型的名称是 \hask{()}，一对空括号，读作 \hask{Unit}。这种符号稍后会更有意义。

 在 Haskell 中有无限多的类型，并且从 \hask{Void} 到每个类型都有一个唯一的函数/箭头。所有这些函数都有相同的名称：\hask{absurd}。

 \begin{center}
  \begin{tabular} {|c | c | c|}
   \hline
   编程 & 范畴论 & 逻辑 \\
   \hline
   类型 & 对象 & 命题 \\
   函数 & 态射（箭头） & 蕴涵 \\
   \hask{Void} & 初始对象，$0$ & False $\bot$ \\
   \hask{()} & 终端对象，$1$ & True $\top$ \\
   \hline

  \end{tabular}
 \end{center}

 \section{Elements\\元素}

 一个对象没有部分，但它可能有结构。结构由指向对象的箭头定义。我们可以用箭头\emph{探测}对象。

 在编程和逻辑中，我们希望初始对象没有结构。所以我们假设它没有入射箭头（除了从它自身回环的那个）。因此 \hask{Void} 没有结构。

 终端对象有最简单的结构。只有一个从任何对象到它的入射箭头：只有一种方式可以从任何方向探测它。在这方面，终端对象表现得像一个不可分割的点。它唯一的属性是它存在，并且从任何其他对象到它的箭头证明了这一点。

 由于终端对象非常简单，我们可以用它来探测其他更复杂的对象。

 如果有多个箭头从终端对象指向某个对象 $a$，这意味着 $a$ 有某种结构：有多种方式可以看待它。由于终端对象表现得像一个点，我们可以将每个箭头视为从它选取目标的不同点或元素。

 在范畴论中，如果 $x$ 是一个箭头，我们说它是 $a$ 的\emph{全局元素}（Global Element）。

 \[ 1 \xrightarrow x a \]

 我们经常简单地称之为元素（省略“全局”）。

 在类型论中，$x \colon A$ 意味着 $x$ 是 $A$ 类型的。

 在 Haskell 中，我们使用双冒号符号：
 \begin{haskell}
  x :: A
 \end{haskell}
 （Haskell 对具体类型使用大写名称，对类型变量使用小写名称。）

 我们说 \hask{x} 是 \hask{A} 类型的一个项，但在范畴论中，我们将其解释为箭头 $x : 1 \to A$，即 \hask{A} 的全局元素。\footnote{Haskell 类型系统区分 \hask{x :: A} 和 \hask{x :: () -> A}。然而，在范畴语义中，它们表示相同的东西。}

 在逻辑中，这样的 $x$ 被称为 $A$ 的证明，因为它对应于蕴涵 $ \top \to A$（如果 \textbf{True} 为真，那么 \textbf{A} 也为真）。请注意，$A$ 可能有许多不同的证明。

 由于我们规定不允许有任何其他对象到 \hask{Void} 的箭头，因此从终端对象到它没有箭头。因此，\hask{Void} 没有元素。这就是为什么我们认为 \hask{Void} 是空的。

 终端对象只有一个元素，因为只有一个从它到它自身的箭头，$1 \to 1$。这就是为什么我们有时称它为单一元素集。

 注意：在范畴论中，没有禁止初始对象从其他对象接收箭头。然而，在我们这里研究的笛卡尔闭范畴中，这是不允许的。

 \section{The Object of Arrows\\箭头的对象}

 任何两个对象之间的箭头形成一个集合\footnote{严格来说，这只在\emph{局部小}范畴中成立。}。这就是为什么集合论的一些知识是学习范畴论的先决条件。

 在编程中，我们谈论从 \hask{a} 到 \hask{b} 的函数的\emph{类型}。在 Haskell 中我们写：
 \begin{haskell}
  f :: a -> b
 \end{haskell}
 意思是 \hask{f} 是“从 \hask{a} 到 \hask{b} 的函数”类型。在这里，\hask{a->b} 只是我们给这个类型起的名字。

 如果我们希望函数类型与其他类型被相同对待，我们需要一个\emph{对象}，它可以表示从 \hask{a} 到 \hask{b} 的箭头集合。

 要完全定义这个对象，我们必须描述它与其他对象的关系，特别是与 \hask{a} 和 \hask{b} 的关系。我们还没有工具来做到这一点，但我们会到达那里。

 目前，让我们记住以下区别：一方面，我们有连接两个对象 \hask{a} 和 \hask{b} 的箭头。这些箭头形成一个集合。另一方面，我们有一个从 \hask{a} 到 \hask{b} 的\emph{箭头对象}。这个对象的“元素”被定义为从终端对象 \hask{()} 到我们称之为 \hask{a->b} 的对象的箭头。

 在编程中我们使用的符号倾向于模糊这个区别。这就是为什么在范畴论中我们称箭头对象为\emph{指数对象}（Exponential Object）并将其写作 $b^a$（源对象在指数中）。因此，以下语句：
 \begin{haskell}
  f :: a -> b
 \end{haskell}
 等同于

 \[ 1 \xrightarrow f b^a\]

 在逻辑中，箭头 $A \to B$ 是一个蕴涵：它陈述了“如果 A，那么 B”的事实。指数对象 $B^A$ 是相应的命题。它可能为真，也可能为假，我们不知道。你必须证明它。这样的证明是 $B^A$ 的一个元素。

 给我看 $B^A$ 的一个元素，我就知道 $B$ 是从 $A$ 推导出来的。

 再考虑一下这个语句，“如果愿望是马，乞丐会骑马”——这次作为一个对象。它不是一个空对象，因为你可以指出它的证明——类似于：“一个有马的人骑马。乞丐有愿望。因为愿望是马，所以乞丐有马。因此，乞丐骑马。”但即使你有这个语句的证明，对你来说也没有用，因为你永远无法证明它的前提：“愿望 = 马”。

\end{document}
